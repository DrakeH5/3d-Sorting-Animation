<html>
  <head><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script></head>
  <body>

        <div style="position: absolute" id="sortingAlgosDiv">

            <h1>Sorting</h1>

            <h2>Speed: <input type="range" min="1" max="100" value="10" class="slider" id="speedSlider"> 
                <Button onclick="finishInstantly = true">Finish</Button>
            </h2>

            <h2>Choose a Sorting Algorithm: 
                <select name="algorithms" id="algorithmsChoice" onchange="ChangedSortingAlgo()">
                    <option value="selectionSort">Selection Sort</option>
                    <option value="BubbleSort">Bubble Sort</option>
                </select>
            </h2>

            <Button onclick="resetArray()">Reset</Button>

        </div>


        <div style="position: absolute; right: 0" id="pathfindingDiv">

            <h1>Pathfinding</h1>

            <h2>Choose a Block Type: 
                <select name="PathfindingBlocks" id="PathfindingBlockChoice" onchange="ChangedPathfindingBlockChoice()" style="background: rgb(139, 135, 135)">
                    <option value="Wall" style="background: rgb(139, 135, 135)">Wall</option>
                    <option value="Start" style="background: rgb(6, 231, 10)">Start</option>
                    <option value="End" style="background: rgb(246, 5, 5)">End</option>
                </select>
            </h2>

        </div>


    <button class="next round" id="rotateBtn" onclick="rotateCamera180()">
        >
    </button>

    <style>
    body {
      margin: 0;
      height: 100vh;
    }

    canvas {
      display: block;
    }

    a {
    text-decoration: none;
    display: inline-block;
    padding: 8px 16px;
    }
    a:hover {
    background-color: #ddd;
    color: black;
    }
    .next {
    background-color: lightblue;
    color: white;
    }
    .round {
    border-radius: 50%;
    }
    #rotateBtn {
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        opacity: 0.5;
        height: 15%;
        width: 10%;
        font-size: 500%;
    }
    </style>


    <script src="./node_modules\three/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    <script src="swap.js"></script>
    <script src="swapColors.js"></script>
    <script src="selectionSort.js"></script>
    <script src="bubbleSort.js"></script>
    <script>
        var scene = new THREE.Scene(); //created a three.js scene

        var camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000) //create a camera
        camera.position.z = 40;
        camera.position.y = 20;
        camera.rotation.y = -6;

        var renderer = new THREE.WebGLRenderer({antialias: true}); //create renderer
        renderer.setClearColor("darkgrey"); //essentially a background color
        renderer.setSize(window.innerWidth,window.innerHeight); //set renderer size to size of the page

        document.body.appendChild(renderer.domElement); //creates a canvas with our render's specifications

        renderer.render(scene, camera); //just render (show) everything on our canvas


        var cubes = [];

        var material = new THREE.MeshLambertMaterial({color: 0xFFCC00});

        for(var i=0; i<100; i++){
            var height = Math.floor(Math.random() * 60) + 1;
            var geometry = new THREE.BoxGeometry(1, height, 1); 
            var cube = new THREE.Mesh(geometry, material);
            scene.add(cube)
            cube.position.x=i-75;
            cube.position.y=(height/2)-15;
            cubes.push(cube);
        }

        function resetArray(){
            for(var i=0; i<cubes.length; i++){
                var height = Math.floor(Math.random() * 60) + 1;
                cubes[i].geometry = new THREE.BoxGeometry(1, height, 1); 
                cubes[i].position.y=(height/2)-15;
            }
            Start()
        }


        var light = new THREE.PointLight(0xFFFFFF, 1, 500); //creates a light (color, intensity, distance)
        light.position.set(10, 0, 25); //sets light position (x, y, z)
        scene.add(light); //add the light to the scene



        var geometry = new THREE.BoxGeometry(1, 0.1, 1); 
            var hightlightMarkerCube = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: "grey"}));
            scene.add(hightlightMarkerCube)
            hightlightMarkerCube.position.y=10000;
        raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        var highlightedCube = hightlightMarkerCube;
        document.body.onmousemove = function(evt) {
            pointer.x = ( evt.clientX / window.innerWidth ) * 2 - 1;
            pointer.y = - ( evt.clientY / window.innerHeight ) * 2 + 1;
            raycaster.setFromCamera( pointer, camera );
			const intersects = raycaster.intersectObjects( scene.children, false );
			if ( intersects.length > 0 && intersects[0].object != highlightedCube && intersects[0].object.position.z > camera.position.z && intersects[0].object.material == material) {
                //swapColor(highlightedCube, 0xFFCC00)
                highlightedCube = intersects[0].object;
                hightlightMarkerCube.position.set(highlightedCube.position.x, highlightedCube.position.y+0.5, highlightedCube.position.z)
                //swapColor(highlightedCube, "grey")
            }
        };

        var pathfindingWalls = [];
        var pathfindingStart ='';
        var pathfindingEnd = '';
        var pathfindingcube;
        document.body.onmousedown = function(evt) {
            geometry = new THREE.BoxGeometry(1, 1, 1); 
            pathfindingcube = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: getColorOfSelectedBlock()}));
            scene.add(pathfindingcube)
            pathfindingcube.position.x=highlightedCube.position.x;
            pathfindingcube.position.y=highlightedCube.position.y+1;
            pathfindingcube.position.z=highlightedCube.position.z;
            if(document.getElementById("PathfindingBlockChoice").value == "Start"){
                if(pathfindingStart.length != 0){
                    pathfindingStart.position.set(-100000, -100000, -10000);
                }
                pathfindingStart = pathfindingcube;
                console.log(pathfindingStart)
            } else if(document.getElementById("PathfindingBlockChoice").value == "End"){
                if(pathfindingEnd.length != 0){
                    pathfindingEnd.position.set(-100000, -100000, -10000);
                }
                pathfindingEnd = pathfindingcube;
            } else {
                pathfindingWalls.push(pathfindingcube)
            }
        }


        var render = function() {
          requestAnimationFrame(render);
          renderer.render(scene, camera); //just render (show) everything on our canvas
        }

        render();


        const delay = () => new Promise(res => setTimeout(res, document.getElementById("speedSlider").value));

        finishInstantly = false;


        function Start(){
            finishInstantly = false;
            if(document.getElementById("algorithmsChoice").value == "selectionSort"){
                selectionSort(cubes)
            } else if(document.getElementById("algorithmsChoice").value == "BubbleSort"){
                BubbleSort(cubes)
            }
        }

        async function ChangedSortingAlgo(){
            finishInstantly = true;
            await delay();
            resetArray();
            Start();
        }


        Start()



        function rotateCamera180(){
            this.tl = new TimelineMax().delay(0); 
            this.tl.to(camera.rotation, 1, {y: camera.rotation.y-Math.PI, ease: Expo.easeOut})
        }



        var light = new THREE.PointLight(0xFFFFFF, 10, 50); //creates a light (color, intensity, distance)
        light.position.set(5, 15, 80); //sets light position (x, y, z)
        scene.add(light); //add the light to the scene

        var pathfindingCubes = [];

        var material = new THREE.MeshLambertMaterial({color: 0xFFCC00});

        for(var i=0; i<15; i++){
            for(var j=0; j<10; j++){
                var geometry = new THREE.BoxGeometry(1, 1, 1); 
                var cube = new THREE.Mesh(geometry, material);
                scene.add(cube)
                cube.position.x=i*1.1-3;
                cube.position.y = 12;
                cube.position.z=j*1.1+53;
                pathfindingCubes.push(cube);
            }
        }


        function getColorOfSelectedBlock(){
            var options = document.getElementById("PathfindingBlockChoice").getElementsByTagName('option')
            for(var i=0; i<options.length; i++){
                if(options[i].value == document.getElementById("PathfindingBlockChoice").value){
                    return options[i].style.background
                }
            }
        }

        function ChangedPathfindingBlockChoice(){
            var options = document.getElementById("PathfindingBlockChoice").getElementsByTagName('option')
            for(var i=0; i<options.length; i++){
                if(options[i].value == document.getElementById("PathfindingBlockChoice").value){
                    document.getElementById("PathfindingBlockChoice").style.background = getColorOfSelectedBlock();
                }
            }
        }
          

    </script>
  </body>
</html>